#!/usr/bin/env python3
"""
Generate a concise Markdown reference of all DocTypes in the TEMS app
with their key properties and field definitions (name, label, type, options, reqd).

Output file: apps/tems/tems/doc/doctype_reference.md

Usage:
  python scripts/generate_doctype_docs.py
"""

from __future__ import annotations

import json
import os
from glob import glob
from typing import Any, Dict, List, Tuple

ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
APP_ROOT = ROOT  # apps/tems/tems
DOC_OUT = os.path.join(APP_ROOT, "doc", "doctype_reference.md")


def find_doctype_jsons(base: str) -> List[str]:
    pattern = os.path.join(base, "**", "doctype", "**", "*.json")
    return sorted(glob(pattern, recursive=True))


def load_json(path: str) -> Dict[str, Any]:
    with open(path, "r", encoding="utf-8") as f:
        return json.load(f)


def extract_fields(doctype_json: Dict[str, Any]) -> List[Dict[str, Any]]:
    fields = doctype_json.get("fields") or []
    out: List[Dict[str, Any]] = []
    for f in fields:
        out.append(
            {
                "fieldname": f.get("fieldname", ""),
                "label": f.get("label", ""),
                "fieldtype": f.get("fieldtype", ""),
                "options": f.get("options", ""),
                "reqd": bool(f.get("reqd")),
                "in_list_view": bool(f.get("in_list_view")),
                "depends_on": f.get("depends_on", ""),
            }
        )
    return out


def module_from_path(path: str, default: str) -> str:
    # Try from json 'module'; fallback to path segment under tems/
    return default


def normalize_module(mod: str | None, path: str) -> str:
    if mod:
        return str(mod)
    # Fallback from path: .../tems/<module>/doctype/...
    parts = os.path.normpath(path).split(os.sep)
    try:
        idx = parts.index("tems")
        # Next segment might be the module folder
        if idx + 1 < len(parts):
            return parts[idx + 1]
    except ValueError:
        pass
    return "tems"


def relpath(path: str) -> str:
    try:
        return os.path.relpath(path, APP_ROOT)
    except Exception:
        return path


def build_markdown(index: Dict[Tuple[str, str], Dict[str, Any]]) -> str:
    # Organize by module then doctype
    modules: Dict[str, List[Tuple[str, Dict[str, Any]]]] = {}
    for (module, doctype), meta in index.items():
        modules.setdefault(module, []).append((doctype, meta))
    for module in modules:
        modules[module].sort(key=lambda x: x[0].lower())

    lines: List[str] = []
    lines.append("# TEMS DocType Reference\n")
    lines.append("This document lists custom DocTypes provided by the TEMS app with their fields to aid API/CRUD development.\n")
    lines.append("Generated by `scripts/generate_doctype_docs.py`.\n")

    # REST API quick guide
    lines.append("## Using with Frappe REST API\n")
    lines.append("Base URL: `/api/resource/{DocType}`\n")
    lines.append("Authentication: Use API Key/Secret headers or session cookie.\n")
    lines.append("Common operations:\n")
    lines.append("- List: `GET /api/resource/{DocType}?fields=[\"name\",...]&filters=[[\"field\",\"=\",\"value\"]]&limit_start=0&limit_page_length=20&order_by=modified desc`\n")
    lines.append("- Get one: `GET /api/resource/{DocType}/{name}`\n")
    lines.append("- Create: `POST /api/resource/{DocType}` with JSON body `{\"fieldname\": value, ...}`\n")
    lines.append("- Update: `PUT /api/resource/{DocType}/{name}` with JSON body for fields to update\n")
    lines.append("- Delete: `DELETE /api/resource/{DocType}/{name}`\n")
    lines.append("Notes: For Link fields, pass the linked document's name. For Table fields (child tables), pass a list of child row dicts under the child fieldname.\n")

    # quick TOC
    lines.append("## Table of contents\n")
    for module in sorted(modules.keys(), key=lambda s: s.lower()):
        lines.append(f"- [{module}](#{module.lower().replace(' ', '-').replace('/', '')})")
        for doctype, _ in modules[module]:
            anchor = f"{module}-{doctype}".lower().replace(" ", "-")
            lines.append(f"  - [{doctype}](#{anchor})")
    lines.append("")

    for module in sorted(modules.keys(), key=lambda s: s.lower()):
        mod_anchor = module.lower().replace(" ", "-").replace("/", "")
        lines.append(f"## {module}\n")
        for doctype, meta in modules[module]:
            anchor = f"{module}-{doctype}".lower().replace(" ", "-")
            lines.append(f"### {doctype}\n")
            lines.append("- Module: " + module)
            lines.append("- File: `" + relpath(meta.get("__path__", "")) + "`")
            lines.append("- Is Child Table: " + ("Yes" if meta.get("istable") else "No"))
            if meta.get("is_submittable"):
                lines.append("- Is Submittable: Yes")
            if meta.get("editable_grid"):
                lines.append("- Editable Grid: Yes")
            if meta.get("autoname"):
                lines.append("- Autoname: `" + str(meta.get("autoname")) + "`")
            if meta.get("naming_rule"):
                lines.append("- Naming Rule: `" + str(meta.get("naming_rule")) + "`")
            if meta.get("engine"):
                lines.append("- Engine: `" + str(meta.get("engine")) + "`")

            fields: List[Dict[str, Any]] = meta.get("__fields__", [])
            if not fields:
                lines.append("\n(No custom fields)\n")
                continue

            lines.append("\nFields:")
            lines.append("")
            lines.append("| Fieldname | Label | Type | Options | Reqd | In List | Depends On |")
            lines.append("|---|---|---|---|:---:|:---:|---|")
            for f in fields:
                fieldname = f.get("fieldname", "")
                label = f.get("label", "")
                ftype = f.get("fieldtype", "")
                opts = f.get("options", "")
                reqd = "✅" if f.get("reqd") else ""
                in_list = "✅" if f.get("in_list_view") else ""
                depends_on = f.get("depends_on", "")
                # escape pipes in text
                def esc(x: Any) -> str:
                    s = str(x) if x is not None else ""
                    return s.replace("|", "\\|")
                lines.append(
                    f"| {esc(fieldname)} | {esc(label)} | {esc(ftype)} | {esc(opts)} | {reqd} | {in_list} | {esc(depends_on)} |"
                )
            lines.append("")
    return "\n".join(lines) + "\n"


def main() -> None:
    json_paths = find_doctype_jsons(APP_ROOT)
    index: Dict[Tuple[str, str], Dict[str, Any]] = {}
    for p in json_paths:
        try:
            data = load_json(p)
        except Exception:
            # Skip non-doctype JSON (if any)
            continue

        if not isinstance(data, dict):
            continue
        # Heuristic: only include if it looks like a DocType JSON
        if data.get("doctype") != "DocType" or not data.get("name"):
            continue

        module = normalize_module(data.get("module"), p)
        doctype = str(data.get("name"))
        meta = {
            "module": module,
            "name": doctype,
            "istable": bool(data.get("istable")),
            "is_submittable": bool(data.get("is_submittable")),
            "editable_grid": bool(data.get("editable_grid")),
            "autoname": data.get("autoname"),
            "naming_rule": data.get("naming_rule"),
            "engine": data.get("engine"),
            "__fields__": extract_fields(data),
            "__path__": p,
        }

        index[(module, doctype)] = meta

    md = build_markdown(index)
    os.makedirs(os.path.dirname(DOC_OUT), exist_ok=True)
    with open(DOC_OUT, "w", encoding="utf-8") as f:
        f.write(md)
    print(f"Wrote {DOC_OUT} with {len(index)} doctypes.")


if __name__ == "__main__":
    main()
